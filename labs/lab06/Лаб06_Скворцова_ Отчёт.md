**Отчет по выполнению лабораторной работы №6**

**Операционные системы**
# Скворцова Анастасия Дмитриевна
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
# Содержание
[1	Цель работы	3](#_toc193544815)

[2	Задание	4](#_toc193544816)

[3	Теоретическое введение	4](#_toc193544817)

[4	Выполнение лабораторной работы	6](#_toc193544818)

[5	Выводы	11](#_toc193544819)

[6	Ответы на контрольные вопросы	12](#_toc193544820)


#
#
#
#
#
#









# <a name="цель-работы"></a><a name="_toc193544815"></a>**1	Цель работы**
Цель данной лабораторной работы - ознакомление с инструментами поиска файлов и фильтрации текстовых данных, а также приобретение практических навыков по управлению процессами (и заданиями), по проверке использования диска и по обслуживанию файловых систем.
#
#
#
#
#
#
#
#
#
#
#



# <a name="задание"></a><a name="_toc193544816"></a>**2	Задание**
1. Осуществите вход в систему, используя соответствующее имя пользователя.
1. Запишите в файл file.txt названия файлов, содержащихся в каталоге /etc. Допи- шите в этот же файл названия файлов, содержащихся в вашем домашнем каталоге.
1. Выведите имена всех файлов из file.txt, имеющих расширение .conf, после чего запишите их в новый текстовой файл conf.txt.
1. Определите, какие файлы в вашем домашнем каталоге имеют имена, начинавшиеся с символа c? Предложите несколько вариантов, как это сделать.
1. Выведите на экран (по странично) имена файлов из каталога /etc, начинающиеся с символа h.
1. Запустите в фоновом режиме процесс, который будет записывать в файл ~/logfile файлы, имена которых начинаются с log.
1. Удалите файл ~/logfile.
1. Запустите из консоли в фоновом режиме редактор gedit.
1. Определите идентификатор процесса gedit, используя команду ps, конвейер и фильтр grep. Как ещё можно определить идентификатор процесса?
1. Прочтите справку (man) команды kill, после чего используйте её для завершения процесса gedit.
1. Выполните команды df и du, предварительно получив более подробную информацию об этих командах, с помощью команды man.
1. Воспользовавшись справкой команды find, выведите имена всех директорий, имею- щихся в вашем домашнем каталоге.
#
#
#
#
# <a name="теоретическое-введение"></a><a name="_toc193544817"></a>** 


# **3	Теоретическое введение**
В интерфейсе командной строки есть очень полезная возможность перенаправления (переадресации) ввода и вывода (англ. термин I/O Redirection). Как мы уже заметили, многие программы выводят данные на экран. А ввод данных в терминале осуществляется с клавиатуры. С помощью специальных обозначений можно перенаправить вывод многих команд в файлы или иные устройства вывода (например, распечатать на принтере). Тоже самое и со вводом информации, вместо ввода данных с клавиатуры, для многих программ можно задать считывание символов их файла. Кроме того, можно даже вывод одной программы передать на ввод другой программе.

К каждой программе, запускаемой в командной строке, по умолчанию подключено три потока данных:

STDIN (0) — стандартный поток ввода (данные, загружаемые в программу). STDOUT (1) — стандартный поток вывода (данные, которые выводит программа). По умолчанию — терминал. STDERR (2) — стандартный поток вывода диагностических и отладочных сообщений (например, сообщениях об ошибках). По умолчанию — терминал.

Pipe (конвеер) – это однонаправленный канал межпроцессного взаимодействия. Термин был придуман Дугласом Макилроем для командной оболочки Unix и назван по аналогии с трубопроводом. Конвейеры чаще всего используются в shell-скриптах для связи нескольких команд путем перенаправления вывода одной команды (stdout) на вход (stdin) последующей, используя символ конвеера ‘|’.
#
#
#
#
#



# <a name="выполнение-лабораторной-работы"></a><a name="_toc193544818"></a>**4	Выполнение лабораторной работы**
Я вошла в систему под соотвествующим именем пользователя, открыла терминал, записала в файл file.txt названия файлов из каталога /etc с помощью перенаправления “>” (и файл создала, и записала в него то, что могло быть выведено ls -lR /etc). В файл я добавила также все файлы из подкаталогов (рис. [1](#fig:001)).

![Figure 1: Запись в файл](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.001.png)

<a name="fig:001"></a>*Figure 1: Запись в файл*

Проверила, что в файл записались нужные значения с помощью утилиты head, она выводит первые 10 строк файла на экран (рис. [2](#fig:002)).

![Figure 2: Вывод содержимого файла](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.002.png)

<a name="fig:002"></a>*Figure 2: Вывод содержимого файла*

Добавила в созданный файл имена файлов из домашнего каталога, используя перенаправление “>>” в режиме добавления (рис. [3](#fig:003)).

![Figure 3: Добавление данных в файл](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.003.png)

<a name="fig:003"></a>*Figure 3: Добавление данных в файл*

Вывела на экран имена всех файлов, имеющих расширение “.conf” с помощью утилиты grep (рис. [4](#fig:004)).

![Figure 4: Поиск файлов определенного расширения](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.004.png)

<a name="fig:004"></a>*Figure 4: Поиск файлов определенного расширения*

Добавила вывод прошлой команды в новый файл conf.txt с помощью перенаправления “>” (файл создается при выполнении этой команды) (рис. [5](#fig:005)).

![Figure 5: Запись в файл](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.005.png)

<a name="fig:005"></a>*Figure 5: Запись в файл*

Определяю,какие файлы в домашнем каталоге начинаютя с символа “c” с помощью утилиты find, прописываю ей в аргументах домашнюю директорию (тогда вывод относительно корневого каталога, а не домашнего будет), выбираю опцию -name (ищем по имени), и пишу маску, по которой будем искать имя, где \* - любое кол-во любых символов, добавляю опцию -print, чтобы мне вывелся результат (рис. [6](#fig:006)). Но таким образом я получаю информацию даже о файлах из подкаталогов домашнего каталога.

![Figure 6: Поиск файлов, начинающихся с определенного элемента](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.006.png)

<a name="fig:006"></a>*Figure 6: Поиск файлов, начинающихся с определенного элемента*

Второй способ использовать утилиту ls -lR и использовать grep, чтобы найти элементы с первым символом c. Однако этот способ не работает для поиска файлов из подкаталогов каталога (рис. [7](#fig:007)).

![Figure 7: Поиск файлов, начинающихся с определенного элемента](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.007.png)

<a name="fig:007"></a>*Figure 7: Поиск файлов, начинающихся с определенного элемента*

С помощью метода find, чьи опции я расписала ранее, ищу все файлы, начинающиеся с буквы “h” (рис. [8](#fig:008)).

![Figure 8: Поиск файлов, начинающихся с определенного элемента](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.008.png)

<a name="fig:008"></a>*Figure 8: Поиск файлов, начинающихся с определенного элемента*

Запускаю в фоновом режиме (на это указывает символ &) процесс, который будет записывать в файл logfile (с помощью перенаправления >) файлы, имена которых начинаются с log (рис. [9](#fig:009)).

![Figure 9: Создание фонового процесса](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.009.png)

<a name="fig:009"></a>*Figure 9: Создание фонового процесса*

Проверяю, что файл создан, удаляю его, проверяю, что файл удален (рис. [10](#fig:010)).

![Figure 10: Удаление файла](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.010.png)

<a name="fig:010"></a>*Figure 10: Удаление файла*

Запускаю в консоли в фоновом режиме (с помощью символа &) редактор mousepad, потому что редактора gedit у меня, к сожалению, но работают они идентично (рис. [11](#fig:011)).

![Figure 11: Создание фонового процесса](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.011.png)

<a name="fig:011"></a>*Figure 11: Создание фонового процесса*

С помощью утилиты ps определяю идентификатор процесса mousepad, его значение 3913 (рис. [12](#fig:012)). Также мы можем определить идентификатор с помощью pgrep.

![Figure 12: Поиск идентификатора процесса](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.012.png)

<a name="fig:012"></a>*Figure 12: Поиск идентификатора процесса*

Прочитала справку команды kill (рис. [13](#fig:013)).

![Figure 13: Чтение документации](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.013.png)

<a name="fig:013"></a>*Figure 13: Чтение документации*

Использую команду kill и идентификатор процесса, чтобы его удалить (рис. [14](#fig:014)). Заметила, как у меня закрылась программа mousepad.

![Figure 14: Удаление процесса](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.014.png)

<a name="fig:014"></a>*Figure 14: Удаление процесса*

Прочитала документацию про функции df и du (рис. [15](#fig:015)).

![Figure 15: Чтение документации](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.015.png)

<a name="fig:015"></a>*Figure 15: Чтение документации*

Использую утилиту df опции -iv позволяют увидеть информацию об инодах и сделать вывод читаемым, игнорируя сообщения системы о нем (рис. [16](#fig:016)). Эта утилита нам нужна, чтобы выяснить, сколько свободного места есть у нашей системы.

![Figure 16: Утилита df](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.016.png)

<a name="fig:016"></a>*Figure 16: Утилита df*

Использую утилиту du. Она нужна чтобы просмотреть, сколько места занимают файлы в определенной директории и найти самые большие из них (рис. [17](#fig:017)).

![Figure 17: Утилита du](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.017.png)

<a name="fig:017"></a>*Figure 17: Утилита du*

Прочитала документацию о команде find (рис. [18](#fig:018)).

![Figure 18: Чтение документации](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.018.png)

<a name="fig:018"></a>*Figure 18: Чтение документации*

Вывела имена всех директорий, имеющихся в моем домашнем каталоге, используя аргумент d у утилиты find опции -type, то есть указываю тип файлов, который мне нужен и этот тип Директория (рис. [19](#fig:019)). Утилита -а позволит увидеть размер всех файлов, а не только диреткорий.

![Figure 19: Название рисунка](Aspose.Words.3dfd43d7-8193-4afe-ae27-e43788a8ae1b.019.png)

<a name="fig:019"></a>*Figure 19: Название рисунка*
# <a name="выводы"></a><a name="_toc193544819"></a>**5	Выводы**
В результате данной лабораторной работы я ознакомилась с инструментами поиска файлов и фильтрации текстовых данных, а также приобрела практические навыки по управлению процессами (и заданиями), по проверке использования диска и по обслуживанию файловых систем.
#
#
#
#
#
#
#
#
#
#
#


# <a name="ответы-на-контрольные-вопросы"></a><a name="_toc193544820"></a>**6	Ответы на контрольные вопросы**
1. Какие потоки ввода вывода вы знаете? В системе по умолчанию открыто три специальных потока: – stdin — стандартный поток ввода (по умолчанию: клавиатура), файловый дескриптор 0; – stdout — стандартный поток вывода (по умолчанию: консоль), файловый дескриптор 1; – stderr — стандартный поток вывод сообщений об ошибках (по умолчанию: консоль), файловый дескриптор 2.
1. Объясните разницу между операцией > и ». Этот знак > - перенаправление ввода/вывода, а » - перенаправление в режиме добавления.
1. Что такое конвейер? Конвейер (pipe) служит для объединения простых команд или утилит в цепочки, в которых результат работы предыдущей команды передаётся последующей.
1. Что такое процесс? Чем это понятие отличается от программы? Главное отличие между программой и процессом заключается в том, что программа - это набор инструкций, который позволяет ЦПУ выполнять определенную задачу, в то время как процесс - это исполняемая программа.
1. Что такое PID и GID? PPID - (parent process ID) идентификатор родительского процесса. Процесс может порождать и другие процессы. UID, GID - реальные идентификаторы пользователя и его группы, запустившего данный процесс.
1. Что такое задачи и какая команда позволяет ими управлять? Запущенные фоном программы называются задачами (jobs). Ими можно управлять с помощью команды jobs, которая выводит список запущенных в данный момент задач.
1. Найдите информацию об утилитах top и htop. Каковы их функции?

Команда htop похожа на команду top по выполняемой функции: они обе показывают информацию о процессах в реальном времени, выводят данные о потреблении системных ресурсов и позволяют искать, останавливать и управлять процессами.

У обеих команд есть свои преимущества. Например, в программе htop реализован очень удобный поиск по процессам, а также их фильтрация. В команде top это не так удобно — нужно знать кнопку для вывода функции поиска.

Зато в top можно разделять область окна и выводить информацию о процессах в соответствии с разными настройками. В целом top намного более гибкая в настройке отображения процессов.

8. Назовите и дайте характеристику команде поиска файлов. Приведите примеры использования этой команды.

Команда find - это одна из наиболее важных и часто используемых утилит системы Linux. Это команда для поиска файлов и каталогов на основе специальных условий. Ее можно использовать в различных обстоятельствах, например, для поиска файлов по разрешениям, владельцам, группам, типу, размеру и другим подобным критериям.

Утилита find предустановлена по умолчанию во всех Linux дистрибутивах, поэтому вам не нужно будет устанавливать никаких дополнительных пакетов. Это очень важная находка для тех, кто хочет использовать командную строку наиболее эффективно.

Команда find имеет такой синтаксис: find [папка] [параметры] критерий шаблон [действие] Пример: find /etc -name “p\*” -print

9. Можно ли по контексту (содержанию) найти файл? Если да, то как? find / -type f -exec grep -H ‘текстДляПоиска’ {} ;
9. Как определить объем свободной памяти на жёстком диске? С помощью команды df -h.
9. Как определить объем вашего домашнего каталога? С помощью команды du -s.
9. Как удалить зависший процесс? С помощью команды kill% номер задачи.
2

